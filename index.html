<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Barber-Mate</title>
    <style>
        /* PROPRIETARY - Multimatic / Michael Barber - Not for external distribution */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0a0e14;
            --bg-panel: #151921;
            --border-color: #2d3748;
            --text-primary: #e8eaed;
            --text-secondary: #9ca3af;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-blue: #3b82f6;
            --accent-yellow: #f59e0b;
            --accent-pink: #ec4899;
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-dark);
            color: var(--text-primary);
            padding: 16px;
            min-height: 100vh;
            -webkit-user-select: none;
            user-select: none;
        }

        .header {
            text-align: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid var(--border-color);
        }

        .header h1 {
            font-size: 22px;
            font-weight: bold;
            letter-spacing: 3px;
            margin-bottom: 8px;
            text-transform: uppercase;
            color: var(--accent-blue);
        }

        .header p {
            font-size: 10px;
            color: var(--text-secondary);
            letter-spacing: 1px;
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            overflow-x: auto;
        }

        .tab {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            padding: 10px 16px;
            font-size: 11px;
            font-weight: bold;
            letter-spacing: 1px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .tab.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: var(--bg-dark);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .status-bar {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-red);
            animation: pulse 2s infinite;
        }

        .status-dot.active {
            background: var(--accent-green);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .control-panel {
            display: grid;
            gap: 8px;
            margin-bottom: 20px;
            grid-template-columns: 1fr 1fr;
        }

        .btn {
            background: var(--bg-panel);
            border: 2px solid var(--border-color);
            color: var(--text-primary);
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn.primary {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: var(--bg-dark);
            grid-column: 1 / -1;
        }

        .btn.primary.recording {
            background: var(--accent-red);
            border-color: var(--accent-red);
            animation: pulse-btn 1.5s infinite;
        }

        @keyframes pulse-btn {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.85; }
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .metrics-grid {
            display: grid;
            gap: 12px;
            margin-bottom: 16px;
        }

        .metric-card {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 16px;
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .metric-label {
            font-size: 11px;
            font-weight: bold;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            color: var(--text-secondary);
        }

        .metric-band {
            font-size: 10px;
            color: var(--text-secondary);
            letter-spacing: 1px;
        }

        .metric-values {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .metric-item {
            text-align: center;
        }

        .metric-item-label {
            font-size: 9px;
            color: var(--text-secondary);
            margin-bottom: 4px;
            letter-spacing: 1px;
        }

        .metric-item-label.bump {
            color: var(--accent-blue);
        }

        .metric-item-label.rebound {
            color: var(--accent-red);
        }

        .metric-value {
            font-size: 28px;
            font-weight: bold;
            font-family: monospace;
            line-height: 1;
        }

        .metric-value.bump {
            color: var(--accent-blue);
        }

        .metric-value.rebound {
            color: var(--accent-red);
        }

        .metric-unit {
            font-size: 11px;
            color: var(--text-secondary);
            margin-left: 4px;
        }

        .balance-bar {
            margin-top: 12px;
            height: 8px;
            background: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .balance-fill {
            position: absolute;
            height: 100%;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-red));
            transition: width 0.3s ease;
        }

        .total-energy {
            background: linear-gradient(135deg, #0d4d3d, #10b981);
            border: 2px solid var(--accent-green);
            border-radius: 4px;
            padding: 20px;
            text-align: center;
        }

        .total-energy-label {
            font-size: 12px;
            color: #ffffff;
            margin-bottom: 8px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .total-energy-value {
            font-size: 48px;
            font-weight: bold;
            color: #ffffff;
            font-family: monospace;
        }

        .plot-container {
            background: white;
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 16px;
            position: relative;
        }

        .plot-header {
            font-family: Arial, sans-serif;
            font-size: 11px;
            color: #000;
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .plot-header strong {
            font-weight: bold;
        }

        canvas {
            display: block;
            width: 100%;
            height: 400px;
            touch-action: none;
        }

        .plot-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin-top: 12px;
        }

        .plot-controls button {
            padding: 8px;
            font-size: 11px;
        }

        .axis-toggles {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .axis-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .axis-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .axis-toggle.x { color: var(--accent-green); }
        .axis-toggle.y { color: var(--accent-pink); }
        .axis-toggle.z { color: var(--accent-blue); }

        .recording-time {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: var(--accent-red);
            margin: 12px 0;
            font-family: monospace;
        }

        .file-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .file-item {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .file-name {
            flex: 1;
            font-size: 12px;
            word-break: break-all;
        }

        .file-actions {
            display: flex;
            gap: 4px;
        }

        .file-actions button {
            padding: 6px 10px;
            font-size: 10px;
        }

        input[type="text"], input[type="number"] {
            width: 100%;
            padding: 8px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-family: monospace;
            border-radius: 4px;
            font-size: 12px;
        }

        .config-section {
            margin-bottom: 16px;
        }

        .config-section label {
            display: block;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .config-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
    </style>
</head>
<body>
    <!-- PROPRIETARY APPLICATION - Multimatic / Michael Barber -->
    
    <div class="header">
        <h1>The Barber-Mate</h1>
        <p>Professional Vibration Analysis System</p>
    </div>

    <div class="tabs">
        <div class="tab active" onclick="switchTab('monitor')">MONITOR</div>
        <div class="tab" onclick="switchTab('psd')">PSD</div>
        <div class="tab" onclick="switchTab('tilt')">TILT</div>
        <div class="tab" onclick="switchTab('vibration')">VIBRATION</div>
        <div class="tab" onclick="switchTab('raw')">RAW</div>
        <div class="tab" onclick="switchTab('files')">FILES</div>
        <div class="tab" onclick="switchTab('config')">CONFIG</div>
    </div>

    <!-- MONITOR TAB -->
    <div id="monitor-tab" class="tab-content active">
        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">STANDBY</span>
            </div>
            <div style="font-size: 11px; color: var(--text-secondary);">
                <span id="sampleCount">0</span> SAMPLES
            </div>
        </div>

        <div class="control-panel">
            <button class="btn primary" id="startBtn" onclick="toggleRecording()">START MONITORING</button>
            <button class="btn" id="resetBtn" onclick="resetMetrics()" disabled>RESET</button>
            <button class="btn" id="saveBtn" onclick="saveResults()" disabled>SAVE</button>
        </div>

        <div id="recordingTime" class="recording-time" style="display: none;">00:00</div>

        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-label">Primary</span>
                    <span class="metric-band" id="band1Range">0.5-3.5 Hz</span>
                </div>
                <div class="metric-values">
                    <div class="metric-item">
                        <div class="metric-item-label bump">BUMP</div>
                        <div class="metric-value bump" id="band1Pos">0.00<span class="metric-unit">g</span></div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-item-label rebound">REBOUND</div>
                        <div class="metric-value rebound" id="band1Neg">0.00<span class="metric-unit">g</span></div>
                    </div>
                </div>
                <div class="balance-bar">
                    <div class="balance-fill" id="band1Bar" style="width: 50%"></div>
                </div>
            </div>

            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-label">Chop</span>
                    <span class="metric-band" id="band2Range">3.5-9 Hz</span>
                </div>
                <div class="metric-values">
                    <div class="metric-item">
                        <div class="metric-item-label bump">BUMP</div>
                        <div class="metric-value bump" id="band2Pos">0.00<span class="metric-unit">g</span></div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-item-label rebound">REBOUND</div>
                        <div class="metric-value rebound" id="band2Neg">0.00<span class="metric-unit">g</span></div>
                    </div>
                </div>
                <div class="balance-bar">
                    <div class="balance-fill" id="band2Bar" style="width: 50%"></div>
                </div>
            </div>

            <div class="metric-card">
                <div class="metric-header">
                    <span class="metric-label">Secondary</span>
                    <span class="metric-band" id="band3Range">9-15 Hz</span>
                </div>
                <div class="metric-values">
                    <div class="metric-item">
                        <div class="metric-item-label bump">BUMP</div>
                        <div class="metric-value bump" id="band3Pos">0.00<span class="metric-unit">g</span></div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-item-label rebound">REBOUND</div>
                        <div class="metric-value rebound" id="band3Neg">0.00<span class="metric-unit">g</span></div>
                    </div>
                </div>
                <div class="balance-bar">
                    <div class="balance-fill" id="band3Bar" style="width: 50%"></div>
                </div>
            </div>
        </div>

        <div class="total-energy">
            <div class="total-energy-label">Total RMS Energy</div>
            <div class="total-energy-value" id="totalRMS">0.000<span class="metric-unit" style="color: #ffffff;">g</span></div>
        </div>

        <div style="text-align: center; margin-top: 16px; font-size: 10px; color: var(--text-secondary);">
            SAMPLE RATE: <span id="sampleRate">0</span> Hz
        </div>
    </div>

    <!-- PSD TAB -->
    <div id="psd-tab" class="tab-content">
        <div class="plot-container">
            <div class="plot-header" id="psdHeader">
                <strong>Title:</strong> <span id="psdTitle">No data loaded</span><br>
                <strong>Start:</strong> <span id="psdStart">--</span><br>
                <strong>Duration:</strong> <span id="psdDuration">--</span><br>
                <strong>Sample Rate:</strong> <span id="psdSampleRate">--</span><br>
                <strong>Units:</strong> m/s²<br>
                <strong>Peak Raw:</strong> X(<span id="psdPeakX">--</span>) Y(<span id="psdPeakY">--</span>) Z(<span id="psdPeakZ">--</span>)<br>
                <strong>ISD:</strong> X(<span id="psdISDX">--</span>) Y(<span id="psdISDY">--</span>) Z(<span id="psdISDZ">--</span>)<br>
                <strong>Resonances X:</strong> <span id="psdResX">--</span><br>
                <strong>Resonances Y:</strong> <span id="psdResY">--</span><br>
                <strong>Resonances Z:</strong> <span id="psdResZ">--</span><br>
                <strong>Avg Tilt:</strong> X(<span id="psdTiltX">--</span>) Y(<span id="psdTiltY">--</span>) Z(<span id="psdTiltZ">--</span>)<br>
                <strong>RMS Vibration:</strong> X(<span id="psdRMSX">--</span>) Y(<span id="psdRMSY">--</span>) Z(<span id="psdRMSZ">--</span>)
            </div>
            <canvas id="psdCanvas"></canvas>
            
            <div class="axis-toggles">
                <label class="axis-toggle x">
                    <input type="checkbox" checked onchange="toggleAxis('x')"> X
                </label>
                <label class="axis-toggle y">
                    <input type="checkbox" checked onchange="toggleAxis('y')"> Y
                </label>
                <label class="axis-toggle z">
                    <input type="checkbox" checked onchange="toggleAxis('z')"> Z
                </label>
            </div>
            
            <div class="plot-controls">
                <button class="btn" onclick="toggleYScale()">Y: <span id="yScaleLabel">LOG</span></button>
                <button class="btn" onclick="setZoom(1)">SCALE: 1X</button>
                <button class="btn" onclick="setZoom(2)">2X</button>
                <button class="btn" onclick="setZoom(5)">5X</button>
                <button class="btn" onclick="setZoom(10)">10X</button>
                <button class="btn" onclick="scrollPlot(-1)">← SCROLL</button>
                <button class="btn" onclick="scrollPlot(1)">SCROLL →</button>
            </div>
        </div>
    </div>

    <!-- TILT TAB -->
    <div id="tilt-tab" class="tab-content">
        <div class="plot-container">
            <div class="plot-header" id="tiltHeader">
                <strong>Tilt Analysis</strong> (Acceleration vs Time)
            </div>
            <canvas id="tiltCanvas"></canvas>
            <div class="axis-toggles">
                <label class="axis-toggle x">
                    <input type="checkbox" checked onchange="updateTiltPlot()"> X
                </label>
                <label class="axis-toggle y">
                    <input type="checkbox" checked onchange="updateTiltPlot()"> Y
                </label>
                <label class="axis-toggle z">
                    <input type="checkbox" checked onchange="updateTiltPlot()"> Z
                </label>
            </div>
        </div>
    </div>

    <!-- VIBRATION TAB -->
    <div id="vibration-tab" class="tab-content">
        <div class="plot-container">
            <div class="plot-header" id="vibrationHeader">
                <strong>Vibration Analysis</strong> (High-pass filtered, Acceleration vs Time)
            </div>
            <canvas id="vibrationCanvas"></canvas>
            <div class="axis-toggles">
                <label class="axis-toggle x">
                    <input type="checkbox" checked onchange="updateVibrationPlot()"> X
                </label>
                <label class="axis-toggle y">
                    <input type="checkbox" checked onchange="updateVibrationPlot()"> Y
                </label>
                <label class="axis-toggle z">
                    <input type="checkbox" checked onchange="updateVibrationPlot()"> Z
                </label>
            </div>
        </div>
    </div>

    <!-- RAW TAB -->
    <div id="raw-tab" class="tab-content">
        <div class="plot-container">
            <div class="plot-header" id="rawHeader">
                <strong>Raw Data</strong> (Acceleration vs Time)
            </div>
            <canvas id="rawCanvas"></canvas>
            <div class="axis-toggles">
                <label class="axis-toggle x">
                    <input type="checkbox" checked onchange="updateRawPlot()"> X
                </label>
                <label class="axis-toggle y">
                    <input type="checkbox" checked onchange="updateRawPlot()"> Y
                </label>
                <label class="axis-toggle z">
                    <input type="checkbox" checked onchange="updateRawPlot()"> Z
                </label>
            </div>
        </div>
    </div>

    <!-- FILES TAB -->
    <div id="files-tab" class="tab-content">
        <div class="metric-card">
            <div class="metric-header">
                <span class="metric-label">Saved Files</span>
            </div>
            <div class="file-list" id="fileList">
                <p style="text-align: center; color: var(--text-secondary); padding: 20px;">No saved files</p>
            </div>
        </div>
    </div>

    <!-- CONFIG TAB -->
    <div id="config-tab" class="tab-content">
        <div class="metric-card">
            <div class="metric-header">
                <span class="metric-label">Configuration</span>
            </div>
            
            <div class="config-section">
                <label>GRAVITY OFFSET (m/s²)</label>
                <input type="number" id="gravityOffset" value="9.8" step="0.1">
            </div>
            
            <div class="config-section">
                <label>FILTER ORDER</label>
                <input type="number" id="filterOrder" value="4" min="2" max="8" step="2">
            </div>
            
            <div class="config-section">
                <label>BAND 1 (PRIMARY) - Hz</label>
                <div class="config-grid">
                    <input type="number" id="band1Low" value="0.5" step="0.1" placeholder="Low">
                    <input type="number" id="band1High" value="3.5" step="0.1" placeholder="High">
                </div>
            </div>
            
            <div class="config-section">
                <label>BAND 2 (CHOP) - Hz</label>
                <div class="config-grid">
                    <input type="number" id="band2Low" value="3.5" step="0.1" placeholder="Low">
                    <input type="number" id="band2High" value="9.0" step="0.1" placeholder="High">
                </div>
            </div>
            
            <div class="config-section">
                <label>BAND 3 (SECONDARY) - Hz</label>
                <div class="config-grid">
                    <input type="number" id="band3Low" value="9.0" step="0.1" placeholder="Low">
                    <input type="number" id="band3High" value="15.0" step="0.1" placeholder="High">
                </div>
            </div>
            
            <button class="btn primary" onclick="applyConfig()">APPLY CONFIGURATION</button>
        </div>
    </div>

    <script>
        // ========================================================================
        // PROPRIETARY CODE - Multimatic / Michael Barber
        // Not for external distribution or submission to AI sites
        // ========================================================================

        // Global state
        let isRecording = false;
        let accelerometerData = [];
        let startTime = 0;
        let recordingInterval = null;
        let lastTimestamp = 0;
        let actualSampleRate = 0;
        let currentDataset = null;
        let savedFiles = [];

        // Configuration
        let config = {
            gravityOffset: 9.8,
            filterOrder: 4,
            bands: [
                { name: 'band1', low: 0.5, high: 3.5, label: 'Primary' },
                { name: 'band2', low: 3.5, high: 9.0, label: 'Chop' },
                { name: 'band3', low: 9.0, high: 15.0, label: 'Secondary' }
            ]
        };

        let bands = [...config.bands];

        // Plot state
        let plotState = {
            yScale: 'log', // 'log' or 'linear'
            zoom: 1,
            scroll: 0,
            visibleAxes: { x: true, y: true, z: true }
        };

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Update plots when switching to plot tabs
            if (currentDataset) {
                if (tabName === 'psd') updatePSDPlot();
                if (tabName === 'tilt') updateTiltPlot();
                if (tabName === 'vibration') updateVibrationPlot();
                if (tabName === 'raw') updateRawPlot();
            }
        }

        // Start/Stop recording
        async function toggleRecording() {
            if (!isRecording) {
                await startRecording();
            } else {
                stopRecording();
            }
        }

        // Start recording
        async function startRecording() {
            try {
                // Request permission for iOS
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    const permission = await DeviceMotionEvent.requestPermission();
                    if (permission !== 'granted') {
                        alert('Permission to access motion sensors was denied.');
                        return;
                    }
                }

                isRecording = true;
                accelerometerData = [];
                lastTimestamp = 0;
                startTime = Date.now();

                // Update UI
                document.getElementById('startBtn').textContent = 'STOP MONITORING';
                document.getElementById('startBtn').classList.add('recording');
                document.getElementById('resetBtn').disabled = true;
                document.getElementById('saveBtn').disabled = true;
                document.getElementById('statusDot').classList.add('active');
                document.getElementById('statusText').textContent = 'RECORDING';
                document.getElementById('recordingTime').style.display = 'block';

                // Start recording timer
                recordingInterval = setInterval(updateRecordingTime, 100);

                // Start listening - request high frequency
                window.addEventListener('devicemotion', handleMotion, { passive: true });

                // Estimate sample rate
                setTimeout(() => {
                    if (accelerometerData.length > 10) {
                        const duration = (accelerometerData[accelerometerData.length - 1].time - 
                                        accelerometerData[0].time) / 1000;
                        actualSampleRate = accelerometerData.length / duration;
                        document.getElementById('sampleRate').textContent = Math.round(actualSampleRate);
                    }
                }, 2000);

            } catch (error) {
                alert('Error accessing accelerometer: ' + error.message);
                isRecording = false;
            }
        }

        // Stop recording
        function stopRecording() {
            isRecording = false;
            window.removeEventListener('devicemotion', handleMotion);
            clearInterval(recordingInterval);

            // Update UI
            document.getElementById('startBtn').textContent = 'START MONITORING';
            document.getElementById('startBtn').classList.remove('recording');
            document.getElementById('resetBtn').disabled = true; // Keep disabled during processing
            document.getElementById('saveBtn').disabled = true;
            document.getElementById('statusDot').classList.remove('active');
            document.getElementById('statusText').textContent = 'PROCESSING...';
            document.getElementById('recordingTime').style.display = 'none';

            // Process data asynchronously to avoid freezing UI
            if (accelerometerData.length > 0) {
                setTimeout(() => {
                    try {
                        processDataset();
                        document.getElementById('statusText').textContent = 'STANDBY';
                        document.getElementById('resetBtn').disabled = false;
                        document.getElementById('saveBtn').disabled = false;
                    } catch (error) {
                        console.error('Processing error:', error);
                        document.getElementById('statusText').textContent = 'ERROR';
                        alert('Error processing data: ' + error.message);
                    }
                }, 100);
            } else {
                document.getElementById('statusText').textContent = 'STANDBY';
                document.getElementById('resetBtn').disabled = false;
            }
        }

        // Handle motion event
        function handleMotion(event) {
            if (!isRecording) return;

            const acc = event.accelerationIncludingGravity;
            if (acc && acc.x !== null && acc.y !== null && acc.z !== null) {
                const now = Date.now();
                
                accelerometerData.push({
                    time: now,
                    x: acc.x,
                    y: acc.y,
                    z: acc.z
                });

                // Update display every 100ms
                if (now - lastTimestamp > 100) {
                    lastTimestamp = now;
                    updateDisplay();
                }
            }
        }

        // Update recording time
        function updateRecordingTime() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('recordingTime').textContent = 
                `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Butterworth bandpass filter
        function bandpassFilter(data, lowFreq, highFreq, sampleRate) {
            if (data.length < 10) return data;
            
            const order = config.filterOrder;
            
            // High-pass stage
            const alphaHP = Math.exp(-2 * Math.PI * lowFreq / sampleRate);
            let highPassed = new Array(data.length);
            highPassed[0] = data[0];
            
            for (let i = 1; i < data.length; i++) {
                highPassed[i] = alphaHP * (highPassed[i-1] + data[i] - data[i-1]);
            }
            
            for (let pass = 1; pass < order / 2; pass++) {
                for (let i = 1; i < highPassed.length; i++) {
                    highPassed[i] = alphaHP * (highPassed[i-1] + highPassed[i] - highPassed[i-1]);
                }
            }
            
            // Low-pass stage
            const alphaLP = Math.exp(-2 * Math.PI * highFreq / sampleRate);
            let bandPassed = new Array(highPassed.length);
            bandPassed[0] = highPassed[0];
            
            for (let i = 1; i < highPassed.length; i++) {
                bandPassed[i] = (1 - alphaLP) * highPassed[i] + alphaLP * bandPassed[i-1];
            }
            
            for (let pass = 1; pass < order / 2; pass++) {
                for (let i = 1; i < bandPassed.length; i++) {
                    bandPassed[i] = (1 - alphaLP) * bandPassed[i] + alphaLP * bandPassed[i-1];
                }
            }
            
            return bandPassed;
        }

        // Calculate RMS in time domain
        function calculateRMSTimedom(filteredData) {
            if (filteredData.length === 0) return { positive: 0, negative: 0, total: 0 };

            const positiveValues = [];
            const negativeValues = [];
            
            for (let i = 0; i < filteredData.length; i++) {
                if (filteredData[i] > 0) {
                    positiveValues.push(filteredData[i]);
                } else if (filteredData[i] < 0) {
                    negativeValues.push(filteredData[i]);
                }
            }

            const rmsPos = positiveValues.length > 0 ? 
                Math.sqrt(positiveValues.reduce((sum, v) => sum + v * v, 0) / positiveValues.length) : 0;
            
            const rmsNeg = negativeValues.length > 0 ? 
                Math.sqrt(negativeValues.reduce((sum, v) => sum + v * v, 0) / negativeValues.length) : 0;

            const rmsTotal = filteredData.length > 0 ? 
                Math.sqrt(filteredData.reduce((sum, v) => sum + v * v, 0) / filteredData.length) : 0;

            return { positive: rmsPos, negative: rmsNeg, total: rmsTotal };
        }

        // Update real-time display
        function updateDisplay() {
            if (accelerometerData.length < 20) return;

            const zData = accelerometerData.map(d => d.z);
            const gravityOffsetValue = config.gravityOffset;
            const zDataNoGravity = zData.map(v => v - gravityOffsetValue);

            let totalRMS = 0;
            let totalSamples = 0;

            bands.forEach(band => {
                const filtered = bandpassFilter(zDataNoGravity, band.low, band.high, actualSampleRate);
                const rms = calculateRMSTimedom(filtered);

                document.getElementById(`${band.name}Pos`).innerHTML = 
                    `${rms.positive.toFixed(3)}<span class="metric-unit">g</span>`;
                document.getElementById(`${band.name}Neg`).innerHTML = 
                    `${rms.negative.toFixed(3)}<span class="metric-unit">g</span>`;

                const total = rms.positive + rms.negative;
                const percentage = total > 0 ? (rms.positive / total * 100) : 50;
                document.getElementById(`${band.name}Bar`).style.width = `${percentage}%`;

                totalRMS += rms.total * rms.total;
                totalSamples++;
            });

            const overallRMS = Math.sqrt(totalRMS / totalSamples);
            document.getElementById('totalRMS').innerHTML = 
                `${overallRMS.toFixed(3)}<span class="metric-unit" style="color: #ffffff;">g</span>`;

            document.getElementById('sampleCount').textContent = accelerometerData.length;
        }

        // FFT calculation (Cooley-Tukey algorithm)
        function fft(real, imag) {
            const n = real.length;
            if (n <= 1) return { real, imag };

            // Bit-reversal permutation
            const j = new Array(n);
            j[0] = 0;
            let m = n >> 1;
            for (let i = 1; i < n; i++) {
                let k = m;
                while (j[i - 1] >= k) {
                    k >>= 1;
                }
                j[i] = j[i - 1] + k - (j[i - 1] & k ? k << 1 : 0);
            }

            const realOut = new Array(n);
            const imagOut = new Array(n);
            for (let i = 0; i < n; i++) {
                realOut[i] = real[j[i]];
                imagOut[i] = imag[j[i]];
            }

            // Cooley-Tukey decimation-in-time FFT
            for (let size = 2; size <= n; size <<= 1) {
                const halfSize = size >> 1;
                const angle = -2 * Math.PI / size;
                
                for (let i = 0; i < n; i += size) {
                    for (let k = 0; k < halfSize; k++) {
                        const tReal = Math.cos(angle * k);
                        const tImag = Math.sin(angle * k);
                        
                        const evenIdx = i + k;
                        const oddIdx = i + k + halfSize;
                        
                        const tempReal = tReal * realOut[oddIdx] - tImag * imagOut[oddIdx];
                        const tempImag = tReal * imagOut[oddIdx] + tImag * realOut[oddIdx];
                        
                        realOut[oddIdx] = realOut[evenIdx] - tempReal;
                        imagOut[oddIdx] = imagOut[evenIdx] - tempImag;
                        realOut[evenIdx] += tempReal;
                        imagOut[evenIdx] += tempImag;
                    }
                }
            }

            return { real: realOut, imag: imagOut };
        }

        // Calculate PSD using Welch's method (faster, more robust)
        function calculatePSD(data, sampleRate) {
            console.log(`Starting PSD for ${data.length} samples at ${sampleRate.toFixed(1)} Hz`);
            
            // Use Welch's method with small segments for speed
            const segmentSize = 256; // Small segments for speed
            const overlap = 128; // 50% overlap
            const numSegments = Math.floor((data.length - overlap) / (segmentSize - overlap));
            
            if (numSegments < 1) {
                console.warn('Not enough data for PSD');
                return { psd: [0], freqs: [0] };
            }
            
            console.log(`Using ${numSegments} segments of ${segmentSize} points`);
            
            // Initialize averaged PSD
            const psdAvg = new Array(segmentSize / 2).fill(0);
            
            // Process each segment
            for (let seg = 0; seg < Math.min(numSegments, 20); seg++) { // Limit to 20 segments max
                const start = seg * (segmentSize - overlap);
                const segment = data.slice(start, start + segmentSize);
                
                if (segment.length < segmentSize) break;
                
                // Apply Hanning window
                const windowed = segment.map((v, i) => 
                    v * 0.5 * (1 - Math.cos(2 * Math.PI * i / (segmentSize - 1)))
                );
                
                // Simple DFT (not FFT) for just the frequencies we need (0-55Hz)
                const df = sampleRate / segmentSize;
                const maxFreq = 55;
                const maxBin = Math.min(segmentSize / 2, Math.ceil(maxFreq / df));
                
                for (let k = 0; k < maxBin; k++) {
                    let real = 0;
                    let imag = 0;
                    const freq = k * df;
                    
                    // Only calculate if frequency is in our range
                    if (freq <= maxFreq) {
                        // Optimized DFT for single frequency
                        const omega = -2 * Math.PI * k / segmentSize;
                        for (let n = 0; n < segmentSize; n++) {
                            const angle = omega * n;
                            real += windowed[n] * Math.cos(angle);
                            imag += windowed[n] * Math.sin(angle);
                        }
                        
                        const power = (real * real + imag * imag) / (segmentSize * segmentSize);
                        psdAvg[k] += power;
                    }
                }
            }
            
            // Average and create frequency array
            const numSegmentsUsed = Math.min(numSegments, 20);
            const psd = [];
            const freqs = [];
            const df = sampleRate / segmentSize;
            
            for (let k = 0; k < psdAvg.length; k++) {
                const freq = k * df;
                if (freq <= 55) {
                    psd.push(psdAvg[k] / numSegmentsUsed);
                    freqs.push(freq);
                }
            }
            
            console.log(`PSD complete: ${freqs.length} points up to ${freqs[freqs.length-1].toFixed(1)} Hz`);
            
            return { psd, freqs };
        }

        // Find resonance peaks
        function findResonances(psd, freqs, count = 2) {
            const peaks = [];
            
            for (let i = 1; i < psd.length - 1; i++) {
                if (psd[i] > psd[i-1] && psd[i] > psd[i+1]) {
                    peaks.push({ freq: freqs[i], power: psd[i] });
                }
            }
            
            peaks.sort((a, b) => b.power - a.power);
            return peaks.slice(0, count);
        }

        // Process dataset for analysis
        function processDataset() {
            if (accelerometerData.length === 0) return;

            console.log('Processing ' + accelerometerData.length + ' samples...');

            const duration = (accelerometerData[accelerometerData.length - 1].time - 
                            accelerometerData[0].time) / 1000;

            currentDataset = {
                title: 'Session ' + new Date().toISOString(),
                startTime: new Date(startTime).toISOString(),
                duration: duration,
                sampleRate: actualSampleRate,
                data: accelerometerData.map(d => ({...d})),
                config: {...config}
            };

            // Calculate statistics (this is quick)
            calculateStatistics();
            
            console.log('Processing complete');
        }

        // Calculate all statistics (quick calculations only, PSD deferred)
        function calculateStatistics() {
            if (!currentDataset) return;

            const data = currentDataset.data;
            
            // Extract axes
            const xData = data.map(d => d.x);
            const yData = data.map(d => d.y);
            const zData = data.map(d => d.z);
            
            // Peak raw values
            currentDataset.peakX = Math.max(...xData.map(Math.abs));
            currentDataset.peakY = Math.max(...yData.map(Math.abs));
            currentDataset.peakZ = Math.max(...zData.map(Math.abs));
            
            // RMS vibration (after removing mean)
            const calcRMS = (data) => {
                const mean = data.reduce((a,b) => a+b, 0) / data.length;
                const deviations = data.map(v => v - mean);
                return Math.sqrt(deviations.reduce((sum, v) => sum + v*v, 0) / data.length);
            };
            
            currentDataset.rmsX = calcRMS(xData);
            currentDataset.rmsY = calcRMS(yData);
            currentDataset.rmsZ = calcRMS(zData);
            
            // PSD will be calculated on-demand when viewing PSD tab
            currentDataset.psd = null;
        }

        // Fast PSD calculation using optimized periodogram method
        function calculatePSD(data, sampleRate) {
            console.log(`Fast PSD starting: ${data.length} samples at ${sampleRate.toFixed(1)} Hz`);
            
            // Downsample aggressively if needed
            let processedData = data;
            let effectiveSampleRate = sampleRate;
            
            if (data.length > 2048) {
                const step = Math.ceil(data.length / 2048);
                processedData = [];
                for (let i = 0; i < data.length; i += step) {
                    processedData.push(data[i]);
                }
                effectiveSampleRate = sampleRate / step;
                console.log(`Downsampled to ${processedData.length} samples at ${effectiveSampleRate.toFixed(1)} Hz`);
            }
            
            // Use 128-point segments for speed
            const segmentSize = 128;
            const numSegments = Math.floor(processedData.length / segmentSize);
            
            if (numSegments < 1) {
                return { psd: [0], freqs: [0] };
            }
            
            const df = effectiveSampleRate / segmentSize;
            const maxFreqBin = Math.min(segmentSize / 2, Math.ceil(55 / df));
            
            const psdSum = new Array(maxFreqBin).fill(0);
            const freqs = [];
            
            for (let i = 0; i < maxFreqBin; i++) {
                freqs.push(i * df);
            }
            
            // Pre-compute trig values for speed
            const cosTable = [];
            const sinTable = [];
            for (let k = 0; k < maxFreqBin; k++) {
                cosTable[k] = [];
                sinTable[k] = [];
                for (let n = 0; n < segmentSize; n++) {
                    const angle = -2 * Math.PI * k * n / segmentSize;
                    cosTable[k][n] = Math.cos(angle);
                    sinTable[k][n] = Math.sin(angle);
                }
            }
            
            // Process segments (limit to 20 for speed)
            const maxSegments = Math.min(numSegments, 20);
            
            for (let seg = 0; seg < maxSegments; seg++) {
                const start = seg * segmentSize;
                const segment = processedData.slice(start, start + segmentSize);
                
                // Apply simple window
                const windowed = [];
                for (let n = 0; n < segmentSize; n++) {
                    const w = 0.5 * (1 - Math.cos(2 * Math.PI * n / (segmentSize - 1)));
                    windowed[n] = segment[n] * w;
                }
                
                // Calculate DFT for each frequency
                for (let k = 0; k < maxFreqBin; k++) {
                    let real = 0;
                    let imag = 0;
                    
                    for (let n = 0; n < segmentSize; n++) {
                        real += windowed[n] * cosTable[k][n];
                        imag += windowed[n] * sinTable[k][n];
                    }
                    
                    const power = (real * real + imag * imag) / (segmentSize * segmentSize);
                    psdSum[k] += power;
                }
            }
            
            // Average and convert to PSD
            const psd = [];
            for (let k = 0; k < maxFreqBin; k++) {
                psd.push(psdSum[k] / maxSegments / effectiveSampleRate);
            }
            
            console.log(`PSD complete: ${freqs.length} frequency points`);
            
            return { psd, freqs };
        }
        
        // Update PSD plot with proper async handling
        function updatePSDPlot() {
            if (!currentDataset) return;
            
            // Calculate PSD if not already calculated
            if (!currentDataset.psd) {
                const statusEl = document.getElementById('psdTitle');
                statusEl.textContent = 'Calculating PSD...';
                statusEl.style.color = '#f59e0b';
                
                // Use requestAnimationFrame to allow UI update before heavy calculation
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        try {
                            const data = currentDataset.data;
                            
                            // Calculate means (fast)
                            const xData = data.map(d => d.x);
                            const yData = data.map(d => d.y);
                            const zData = data.map(d => d.z);
                            
                            const tiltX = xData.reduce((a,b) => a+b, 0) / xData.length;
                            const tiltY = yData.reduce((a,b) => a+b, 0) / yData.length;
                            const tiltZ = zData.reduce((a,b) => a+b, 0) / zData.length;
                            
                            currentDataset.tiltX = tiltX;
                            currentDataset.tiltY = tiltY;
                            currentDataset.tiltZ = tiltZ;
                            
                            // Remove DC component
                            const xCentered = xData.map(v => v - tiltX);
                            const yCentered = yData.map(v => v - tiltY);
                            const zCentered = zData.map(v => v - tiltZ);
                            
                            statusEl.textContent = 'Calculating X axis...';
                            const xPSD = calculatePSD(xCentered, currentDataset.sampleRate);
                            
                            statusEl.textContent = 'Calculating Y axis...';
                            const yPSD = calculatePSD(yCentered, currentDataset.sampleRate);
                            
                            statusEl.textContent = 'Calculating Z axis...';
                            const zPSD = calculatePSD(zCentered, currentDataset.sampleRate);
                            
                            currentDataset.psd = {
                                x: xPSD,
                                y: yPSD,
                                z: zPSD
                            };
                            
                            statusEl.textContent = 'Finding resonances...';
                            
                            // Find resonances
                            currentDataset.resonancesX = findResonances(xPSD.psd, xPSD.freqs);
                            currentDataset.resonancesY = findResonances(yPSD.psd, yPSD.freqs);
                            currentDataset.resonancesZ = findResonances(zPSD.psd, zPSD.freqs);
                            
                            // Calculate ISD
                            currentDataset.isdX = xPSD.psd.reduce((a,b) => a+b, 0);
                            currentDataset.isdY = yPSD.psd.reduce((a,b) => a+b, 0);
                            currentDataset.isdZ = zPSD.psd.reduce((a,b) => a+b, 0);
                            
                            statusEl.style.color = '';
                            
                            // Update display
                            updatePSDDisplay();
                            
                        } catch (error) {
                            console.error('PSD error:', error);
                            statusEl.textContent = 'ERROR: ' + error.message;
                            statusEl.style.color = '#ef4444';
                        }
                    });
                });
                
                return;
            }
            
            // PSD already calculated
            updatePSDDisplay();
        }

        // Update PSD display (separate from calculation)
        function updatePSDDisplay() {
            if (!currentDataset || !currentDataset.psd) return;

            // Update header info
            document.getElementById('psdTitle').textContent = currentDataset.title;
            document.getElementById('psdStart').textContent = new Date(currentDataset.startTime).toLocaleString();
            document.getElementById('psdDuration').textContent = currentDataset.duration.toFixed(2) + ' sec';
            document.getElementById('psdSampleRate').textContent = currentDataset.sampleRate.toFixed(1) + ' Hz';
            
            document.getElementById('psdPeakX').textContent = currentDataset.peakX.toFixed(2);
            document.getElementById('psdPeakY').textContent = currentDataset.peakY.toFixed(2);
            document.getElementById('psdPeakZ').textContent = currentDataset.peakZ.toFixed(2);
            
            document.getElementById('psdISDX').textContent = currentDataset.isdX.toFixed(2);
            document.getElementById('psdISDY').textContent = currentDataset.isdY.toFixed(2);
            document.getElementById('psdISDZ').textContent = currentDataset.isdZ.toFixed(2);
            
            const formatRes = (res) => res.map(r => `${r.freq.toFixed(1)} Hz (${r.power.toFixed(2)})`).join(', ');
            document.getElementById('psdResX').textContent = formatRes(currentDataset.resonancesX);
            document.getElementById('psdResY').textContent = formatRes(currentDataset.resonancesY);
            document.getElementById('psdResZ').textContent = formatRes(currentDataset.resonancesZ);
            
            document.getElementById('psdTiltX').textContent = currentDataset.tiltX.toFixed(2);
            document.getElementById('psdTiltY').textContent = currentDataset.tiltY.toFixed(2);
            document.getElementById('psdTiltZ').textContent = currentDataset.tiltZ.toFixed(2);
            
            document.getElementById('psdRMSX').textContent = currentDataset.rmsX.toFixed(3);
            document.getElementById('psdRMSY').textContent = currentDataset.rmsY.toFixed(3);
            document.getElementById('psdRMSZ').textContent = currentDataset.rmsZ.toFixed(3);

            // Draw plot
            drawPSDPlot();
        }

        // Draw PSD plot on canvas
        function drawPSDPlot() {
            const canvas = document.getElementById('psdCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const w = canvas.width;
            const h = canvas.height;
            
            // Clear
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, w, h);
            
            // Margins
            const margin = { top: 20, right: 30, bottom: 50, left: 70 };
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;
            
            // Get data
            const freqs = currentDataset.psd.x.freqs;
            const maxFreq = Math.min(55, freqs[freqs.length - 1]);
            
            // Apply zoom and scroll
            const zoomedMaxFreq = maxFreq / plotState.zoom;
            const scrollOffset = plotState.scroll * zoomedMaxFreq * 0.1;
            const visibleMinFreq = Math.max(0, scrollOffset);
            const visibleMaxFreq = Math.min(maxFreq, visibleMinFreq + zoomedMaxFreq);
            
            // Find max power for scaling
            let maxPower = 0;
            ['x', 'y', 'z'].forEach(axis => {
                if (plotState.visibleAxes[axis]) {
                    currentDataset.psd[axis].psd.forEach((p, i) => {
                        if (freqs[i] >= visibleMinFreq && freqs[i] <= visibleMaxFreq) {
                            maxPower = Math.max(maxPower, p);
                        }
                    });
                }
            });
            
            // Y-scale function
            const yScale = (value) => {
                if (plotState.yScale === 'log') {
                    const logMin = -2; // 10^-2 = 0.01
                    const logMax = Math.log10(maxPower) + 0.5;
                    const logValue = Math.log10(Math.max(value, 1e-10));
                    return margin.top + plotH * (1 - (logValue - logMin) / (logMax - logMin));
                } else {
                    return margin.top + plotH * (1 - value / maxPower);
                }
            };
            
            // X-scale function
            const xScale = (freq) => {
                return margin.left + plotW * (freq - visibleMinFreq) / (visibleMaxFreq - visibleMinFreq);
            };
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            // Vertical grid lines
            const freqStep = plotState.zoom >= 5 ? 1 : (plotState.zoom >= 2 ? 5 : 10);
            for (let f = Math.ceil(visibleMinFreq / freqStep) * freqStep; f <= visibleMaxFreq; f += freqStep) {
                const x = xScale(f);
                ctx.beginPath();
                ctx.moveTo(x, margin.top);
                ctx.lineTo(x, margin.top + plotH);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            if (plotState.yScale === 'log') {
                for (let logPower = -2; logPower <= Math.log10(maxPower) + 1; logPower++) {
                    const y = yScale(Math.pow(10, logPower));
                    if (y >= margin.top && y <= margin.top + plotH) {
                        ctx.beginPath();
                        ctx.moveTo(margin.left, y);
                        ctx.lineTo(margin.left + plotW, y);
                        ctx.stroke();
                    }
                }
            } else {
                for (let i = 0; i <= 5; i++) {
                    const y = margin.top + (plotH * i / 5);
                    ctx.beginPath();
                    ctx.moveTo(margin.left, y);
                    ctx.lineTo(margin.left + plotW, y);
                    ctx.stroke();
                }
            }
            
            // Draw axes
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + plotH);
            ctx.lineTo(margin.left + plotW, margin.top + plotH);
            ctx.stroke();
            
            // Draw data
            const colors = { x: '#10b981', y: '#ec4899', z: '#3b82f6' };
            
            ['x', 'y', 'z'].forEach(axis => {
                if (!plotState.visibleAxes[axis]) return;
                
                ctx.strokeStyle = colors[axis];
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                let first = true;
                currentDataset.psd[axis].psd.forEach((p, i) => {
                    const f = freqs[i];
                    if (f >= visibleMinFreq && f <= visibleMaxFreq) {
                        const x = xScale(f);
                        const y = yScale(p);
                        
                        if (first) {
                            ctx.moveTo(x, y);
                            first = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                });
                
                ctx.stroke();
            });
            
            // Draw labels
            ctx.fillStyle = 'black';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            // X-axis label
            ctx.fillText('Frequency (Hz)', margin.left + plotW / 2, h - 10);
            
            // X-axis tick labels
            for (let f = Math.ceil(visibleMinFreq / freqStep) * freqStep; f <= visibleMaxFreq; f += freqStep) {
                const x = xScale(f);
                ctx.fillText(f.toString(), x, margin.top + plotH + 20);
            }
            
            // Y-axis label
            ctx.save();
            ctx.translate(15, margin.top + plotH / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('PSD (m²/s³)', 0, 0);
            ctx.restore();
            
            // Y-axis tick labels
            ctx.textAlign = 'right';
            if (plotState.yScale === 'log') {
                for (let logPower = -2; logPower <= Math.log10(maxPower) + 1; logPower++) {
                    const y = yScale(Math.pow(10, logPower));
                    if (y >= margin.top && y <= margin.top + plotH) {
                        ctx.fillText(`1e${logPower}`, margin.left - 10, y + 4);
                    }
                }
            } else {
                for (let i = 0; i <= 5; i++) {
                    const value = maxPower * (1 - i / 5);
                    const y = margin.top + (plotH * i / 5);
                    ctx.fillText(value.toFixed(2), margin.left - 10, y + 4);
                }
            }
        }

        // Plot control functions
        function toggleYScale() {
            plotState.yScale = plotState.yScale === 'log' ? 'linear' : 'log';
            document.getElementById('yScaleLabel').textContent = plotState.yScale.toUpperCase();
            if (currentDataset) drawPSDPlot();
        }

        function setZoom(level) {
            plotState.zoom = level;
            plotState.scroll = 0;
            if (currentDataset) drawPSDPlot();
        }

        function scrollPlot(direction) {
            plotState.scroll += direction;
            if (currentDataset) drawPSDPlot();
        }

        function toggleAxis(axis) {
            plotState.visibleAxes[axis] = event.target.checked;
            if (currentDataset) drawPSDPlot();
        }

        // Update Tilt plot (raw acceleration including gravity vs time)
        function updateTiltPlot() {
            if (!currentDataset) return;

            const canvas = document.getElementById('tiltCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, w, h);
            
            const margin = { top: 20, right: 30, bottom: 50, left: 70 };
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;
            
            const data = currentDataset.data;
            const times = data.map((d, i) => i / currentDataset.sampleRate);
            const maxTime = times[times.length - 1];
            
            // Find max/min for scaling
            let maxAcc = -Infinity, minAcc = Infinity;
            ['x', 'y', 'z'].forEach(axis => {
                const axisCheckbox = document.querySelector(`#tilt-tab .axis-toggle.${axis} input`);
                if (axisCheckbox && axisCheckbox.checked) {
                    data.forEach(d => {
                        maxAcc = Math.max(maxAcc, d[axis]);
                        minAcc = Math.min(minAcc, d[axis]);
                    });
                }
            });
            
            const accRange = maxAcc - minAcc;
            
            // Scale functions
            const xScale = (time) => margin.left + (time / maxTime) * plotW;
            const yScale = (acc) => margin.top + plotH * (1 - (acc - minAcc) / accRange);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = margin.top + (plotH * i / 5);
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(margin.left + plotW, y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + plotH);
            ctx.lineTo(margin.left + plotW, margin.top + plotH);
            ctx.stroke();
            
            // Draw data
            const colors = { x: '#10b981', y: '#ec4899', z: '#3b82f6' };
            
            ['x', 'y', 'z'].forEach(axis => {
                const axisCheckbox = document.querySelector(`#tilt-tab .axis-toggle.${axis} input`);
                if (!axisCheckbox || !axisCheckbox.checked) return;
                
                ctx.strokeStyle = colors[axis];
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                data.forEach((d, i) => {
                    const x = xScale(times[i]);
                    const y = yScale(d[axis]);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                
                ctx.stroke();
            });
            
            // Labels
            ctx.fillStyle = 'black';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Time (s)', margin.left + plotW / 2, h - 10);
            
            ctx.save();
            ctx.translate(15, margin.top + plotH / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Acceleration (m/s²)', 0, 0);
            ctx.restore();
            
            // Y-axis ticks
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const value = maxAcc - (accRange * i / 5);
                const y = margin.top + (plotH * i / 5);
                ctx.fillText(value.toFixed(2), margin.left - 10, y + 4);
            }
            
            // X-axis ticks
            ctx.textAlign = 'center';
            for (let i = 0; i <= 5; i++) {
                const time = (maxTime * i / 5);
                const x = margin.left + (plotW * i / 5);
                ctx.fillText(time.toFixed(1), x, margin.top + plotH + 20);
            }
        }

        // Update Vibration plot (high-pass filtered data vs time)
        function updateVibrationPlot() {
            if (!currentDataset) return;

            const canvas = document.getElementById('vibrationCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, w, h);
            
            const margin = { top: 20, right: 30, bottom: 50, left: 70 };
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;
            
            const data = currentDataset.data;
            const times = data.map((d, i) => i / currentDataset.sampleRate);
            const maxTime = times[times.length - 1];
            
            // Apply high-pass filter to remove DC (gravity) component
            const highPassCutoff = 0.5; // Hz
            const filteredData = {};
            
            ['x', 'y', 'z'].forEach(axis => {
                const rawData = data.map(d => d[axis]);
                filteredData[axis] = bandpassFilter(rawData, highPassCutoff, 55, currentDataset.sampleRate);
            });
            
            // Find max/min for scaling
            let maxAcc = -Infinity, minAcc = Infinity;
            ['x', 'y', 'z'].forEach(axis => {
                const axisCheckbox = document.querySelector(`#vibration-tab .axis-toggle.${axis} input`);
                if (axisCheckbox && axisCheckbox.checked) {
                    filteredData[axis].forEach(v => {
                        maxAcc = Math.max(maxAcc, v);
                        minAcc = Math.min(minAcc, v);
                    });
                }
            });
            
            const accRange = Math.max(Math.abs(maxAcc), Math.abs(minAcc)) * 2;
            const centerAcc = 0;
            
            // Scale functions
            const xScale = (time) => margin.left + (time / maxTime) * plotW;
            const yScale = (acc) => margin.top + plotH / 2 - (acc / accRange) * plotH;
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = margin.top + (plotH * i / 5);
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(margin.left + plotW, y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + plotH);
            ctx.lineTo(margin.left + plotW, margin.top + plotH);
            ctx.stroke();
            
            // Draw zero line
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(margin.left, yScale(0));
            ctx.lineTo(margin.left + plotW, yScale(0));
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw data
            const colors = { x: '#10b981', y: '#ec4899', z: '#3b82f6' };
            
            ['x', 'y', 'z'].forEach(axis => {
                const axisCheckbox = document.querySelector(`#vibration-tab .axis-toggle.${axis} input`);
                if (!axisCheckbox || !axisCheckbox.checked) return;
                
                ctx.strokeStyle = colors[axis];
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                filteredData[axis].forEach((v, i) => {
                    const x = xScale(times[i]);
                    const y = yScale(v);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                
                ctx.stroke();
            });
            
            // Labels
            ctx.fillStyle = 'black';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Time (s)', margin.left + plotW / 2, h - 10);
            
            ctx.save();
            ctx.translate(15, margin.top + plotH / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Acceleration (m/s²)', 0, 0);
            ctx.restore();
        }

        // Update Raw plot (completely unfiltered data vs time)
        function updateRawPlot() {
            if (!currentDataset) return;

            const canvas = document.getElementById('rawCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, w, h);
            
            const margin = { top: 20, right: 30, bottom: 50, left: 70 };
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;
            
            const data = currentDataset.data;
            const times = data.map((d, i) => i / currentDataset.sampleRate);
            const maxTime = times[times.length - 1];
            
            // Find max/min for scaling (raw data)
            let maxAcc = -Infinity, minAcc = Infinity;
            ['x', 'y', 'z'].forEach(axis => {
                const axisCheckbox = document.querySelector(`#raw-tab .axis-toggle.${axis} input`);
                if (axisCheckbox && axisCheckbox.checked) {
                    data.forEach(d => {
                        maxAcc = Math.max(maxAcc, d[axis]);
                        minAcc = Math.min(minAcc, d[axis]);
                    });
                }
            });
            
            const accRange = maxAcc - minAcc;
            
            // Scale functions
            const xScale = (time) => margin.left + (time / maxTime) * plotW;
            const yScale = (acc) => margin.top + plotH * (1 - (acc - minAcc) / accRange);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = margin.top + (plotH * i / 5);
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(margin.left + plotW, y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + plotH);
            ctx.lineTo(margin.left + plotW, margin.top + plotH);
            ctx.stroke();
            
            // Draw data
            const colors = { x: '#10b981', y: '#ec4899', z: '#3b82f6' };
            
            ['x', 'y', 'z'].forEach(axis => {
                const axisCheckbox = document.querySelector(`#raw-tab .axis-toggle.${axis} input`);
                if (!axisCheckbox || !axisCheckbox.checked) return;
                
                ctx.strokeStyle = colors[axis];
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                
                // Downsample for performance if needed
                const step = Math.max(1, Math.floor(data.length / 5000));
                
                for (let i = 0; i < data.length; i += step) {
                    const x = xScale(times[i]);
                    const y = yScale(data[i][axis]);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                
                ctx.stroke();
            });
            
            // Labels
            ctx.fillStyle = 'black';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Time (s)', margin.left + plotW / 2, h - 10);
            
            ctx.save();
            ctx.translate(15, margin.top + plotH / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Acceleration (m/s²)', 0, 0);
            ctx.restore();
            
            // Y-axis ticks
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const value = maxAcc - (accRange * i / 5);
                const y = margin.top + (plotH * i / 5);
                ctx.fillText(value.toFixed(2), margin.left - 10, y + 4);
            }
            
            // X-axis ticks
            ctx.textAlign = 'center';
            for (let i = 0; i <= 5; i++) {
                const time = (maxTime * i / 5);
                const x = margin.left + (plotW * i / 5);
                ctx.fillText(time.toFixed(1), x, margin.top + plotH + 20);
            }
        }

        // Save results
        function saveResults() {
            if (!currentDataset) {
                alert('No data to save!');
                return;
            }

            const defaultName = 'barber-mate-' + new Date().toISOString().slice(0,19).replace(/:/g,'-');
            const filename = prompt('Enter filename:', defaultName);
            
            if (!filename) return;

            currentDataset.filename = filename;
            
            // Save to localStorage
            savedFiles.push({...currentDataset});
            localStorage.setItem('barberMateFiles', JSON.stringify(savedFiles));
            
            // Also download as JSON
            const jsonStr = JSON.stringify(currentDataset, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            alert('Results saved as ' + filename + '.json');
            updateFileList();
        }

        // Update file list display
        function updateFileList() {
            const stored = localStorage.getItem('barberMateFiles');
            if (stored) {
                savedFiles = JSON.parse(stored);
            }
            
            const fileListEl = document.getElementById('fileList');
            
            if (savedFiles.length === 0) {
                fileListEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">No saved files</p>';
                return;
            }
            
            fileListEl.innerHTML = '';
            
            savedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                
                const fileName = document.createElement('div');
                fileName.className = 'file-name';
                fileName.textContent = file.filename || file.title;
                
                const actions = document.createElement('div');
                actions.className = 'file-actions';
                
                const loadBtn = document.createElement('button');
                loadBtn.className = 'btn';
                loadBtn.textContent = 'LOAD';
                loadBtn.onclick = () => loadFile(index);
                
                const renameBtn = document.createElement('button');
                renameBtn.className = 'btn';
                renameBtn.textContent = 'RENAME';
                renameBtn.onclick = () => renameFile(index);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn';
                deleteBtn.textContent = 'DELETE';
                deleteBtn.style.color = 'var(--accent-red)';
                deleteBtn.onclick = () => deleteFile(index);
                
                actions.appendChild(loadBtn);
                actions.appendChild(renameBtn);
                actions.appendChild(deleteBtn);
                
                fileItem.appendChild(fileName);
                fileItem.appendChild(actions);
                
                fileListEl.appendChild(fileItem);
            });
        }

        // Load file from saved files
        function loadFile(index) {
            currentDataset = {...savedFiles[index]};
            calculateStatistics();
            alert('File loaded: ' + currentDataset.filename);
            switchTab('psd');
        }

        // Rename file
        function renameFile(index) {
            const newName = prompt('Enter new filename:', savedFiles[index].filename);
            if (newName && newName.trim()) {
                savedFiles[index].filename = newName.trim();
                localStorage.setItem('barberMateFiles', JSON.stringify(savedFiles));
                updateFileList();
                
                // Update current dataset if it's the one we renamed
                if (currentDataset && currentDataset.filename === savedFiles[index].filename) {
                    currentDataset.filename = newName.trim();
                }
            }
        }

        // Delete file
        function deleteFile(index) {
            if (confirm('Delete file: ' + savedFiles[index].filename + '?')) {
                savedFiles.splice(index, 1);
                localStorage.setItem('barberMateFiles', JSON.stringify(savedFiles));
                updateFileList();
            }
        }

        // Reset metrics
        function resetMetrics() {
            accelerometerData = [];
            currentDataset = null;
            
            ['band1', 'band2', 'band3'].forEach(band => {
                document.getElementById(`${band}Pos`).innerHTML = '0.00<span class="metric-unit">g</span>';
                document.getElementById(`${band}Neg`).innerHTML = '0.00<span class="metric-unit">g</span>';
                document.getElementById(`${band}Bar`).style.width = '50%';
            });
            
            document.getElementById('totalRMS').innerHTML = '0.000<span class="metric-unit" style="color: #ffffff;">g</span>';
            document.getElementById('sampleCount').textContent = '0';
            document.getElementById('saveBtn').disabled = true;
        }

        // Apply configuration
        function applyConfig() {
            config.gravityOffset = parseFloat(document.getElementById('gravityOffset').value);
            config.filterOrder = parseInt(document.getElementById('filterOrder').value);
            
            config.bands[0].low = parseFloat(document.getElementById('band1Low').value);
            config.bands[0].high = parseFloat(document.getElementById('band1High').value);
            config.bands[1].low = parseFloat(document.getElementById('band2Low').value);
            config.bands[1].high = parseFloat(document.getElementById('band2High').value);
            config.bands[2].low = parseFloat(document.getElementById('band3Low').value);
            config.bands[2].high = parseFloat(document.getElementById('band3High').value);
            
            bands = [...config.bands];
            
            document.getElementById('band1Range').textContent = `${bands[0].low}-${bands[0].high} Hz`;
            document.getElementById('band2Range').textContent = `${bands[1].low}-${bands[1].high} Hz`;
            document.getElementById('band3Range').textContent = `${bands[2].low}-${bands[2].high} Hz`;
            
            alert('Configuration applied!');
            switchTab('monitor');
        }

        // Check sensor support on load
        window.addEventListener('load', () => {
            if (!window.DeviceMotionEvent) {
                alert('This device does not support motion sensors.');
            }
            updateFileList();
        });
    </script>
</body>
</html>
